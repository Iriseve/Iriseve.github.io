[{"content":" 发生背景是由于手贱不小心把Mysql Server后台直接关闭（非正常服务关闭）重启时遇到的一系列问题\n发现 本地连接数据库发现连不上，并报错ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost:3306' (10061)，才发现是把mysql服务给关了呜呜\n解决方案 1. Win+R显示运行窗口输入services.msc进入服务窗口，如下 一开始是没有找到的，如果找到了可以直接跳到第三步。\n2. 进入cmd输入mysqld.exe --install命令 在这一步如果报错Install/Remove of the Service Denied!那就用管理员身份打开cmd.exe\n3.执行完再回到第一步就能找到mysql啦 找到后直接右键启动，如果启动成龚就不用往下看了，不过大概率当你看到本篇文章是还木有成功的,会有如下报错\n4. 猜测可能是和异常关闭有关系（没验证过哈，自己猜的） 先将原来的Data数据备份（这是我的目录，原来没修改默认路径，如果你也找不到data，可以看看在不在这里）\n一定要备份！！数据库数据模型的数据（包括表、记录等）都在Data下。\n然后清空原来的Data目录。\n删除原来的服务。\n以管理员身份进入cmd,输入如下命令\n\u0026gt;mysqld --remove mysql Service successfully removed. 初始化mysql。\n这里有个小坑，使用--insecure参数初始化，生成的是空密码/虽然影响也不大，之后初次登录直接回车就行了。如果想生成随机密码，建议去掉试试。\n\u0026gt;mysqld --initialize-insecure --user=mysql 安装mysql服务\n\u0026gt;mysqld --install Service successfully installed. 到这基本服务就重装好啦。不过别急着重启服务，先把我们之前的备份Data的内容覆盖新生成的data文件夹/原来安装时我们的数据默认保存在C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data下，重装以后好像是直接和\\MySQL Server 8.0\\bin同级目录下的data啦。\n重启服务\nnet start mysql 这里再写个停止服务的命令\nnet stop mysql 如果遇到以下错误，请使用管理员身份运行cmd\n试一试连接\nmysql -u root -p 密码为空，直接回车，应该是能登上的\n然后修改密码。\nmysql\u0026gt; ALTER user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新密码\u0026#39;; mysql\u0026gt; flush privileges; 题外话 这里直接在cmd运行mysql的一些命令是在系统环境变量里都配好了mysql的环境哦，没配的只要在如下位置添加地址\n参考博客 (57条消息) 连接本地mysql时出现2003-Can‘t connect to MySql server on ‘localhost‘(10061)错误_柠檬草。的博客-CSDN博客\n(57条消息) 【错误解决】本地计算机上的mysql服务启动停止后,某些服务在未由_本地计算机上的mysql服务启动后停止 某些-CSDN博客\n(57条消息) 解决“本地计算机上的 mysql 服务启动后停止，某些服务在未由其他服务或程序使用时将自动停止”_本地计算机上的mysql服务启动后停止 某些_Percep_gan的博客-CSDN博客\n","permalink":"https://iriseve.github.io/posts/env_deploy/mysql%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%90%AF/","summary":"Mysql Server被意外关闭后重启遇到的一些小问题","title":"Mysql服务重启"},{"content":"题目 题目链接： 3777. 砖块 - AcWing题库\n$n$个砖块排成一排，从左到右编号依次为$1∼n$。\n每个砖块要么是黑色的，要么是白色的。\n现在你可以进行以下操作若干次（可以是$0$次）：\n选择两个相邻的砖块，反转它们的颜色。（黑变白，白变黑）\n你的目标是通过不超过$3 n$次操作，将所有砖块的颜色变得一致。\n输入格式 第一行包含整数 $T$，表示共有$ T$ 组测试数据。\n每组数据第一行包含一个整数 $n$。\n第二行包含一个长度为$n$的字符串$s$。其中的每个字符都是 W 或 B，如果第 $i$个字符是 W，则表示第$i$号砖块是白色的，如果第$i$个字符是 B，则表示第$i$个砖块是黑色的。\n输出格式 每组数据，如果无解则输出一行 $−1$。\n否则，首先输出一行 $k$，表示需要的操作次数。\n如果$k\u0026gt;0$，则还需再输出一行$k$个整数，$p_1,p_2,…,p_k$。其中$p_i$表示第$i$次操作，选中的砖块为$p_i$和$p_i+1$号砖块。\n如果方案不唯一，则输出任意合理方案即可。\n数据范围 $1≤T≤10$， $2≤n≤200$。\n输入样例： 4 8 BWWWWWWB 4 BWBB 5 WWWWW 3 BWB 输出样例： 3 6 2 4 -1 0 2 2 1 分析 砖块颜色一共就两种黑和白，所以最后在反转颜色完毕成功后的目标颜色也只可能有两种。\n那么题目就转变为反转相邻的任意两块砖，最后使得所有砖块颜色为黑或者白\n现在来考虑下如何翻转？\n由于$p_i$表示操作的是$p_i$和$p_i+1$号砖，对于第$i$块砖，$p_i=i$或$p_i=i-1$ $(i\u0026gt;1)$\n所以想操作第一号砖只可能是$p_i=1$,想操作最后一块砖一定是$p_i=i-1$。\n同时对同一块砖翻转两次相当于没有翻转（和原来是一样的），所以对同一块砖翻转次数只可能是$0$次或$1$次。\n翻转顺序对结果没影响，所以我们可以找一种最容易观察的翻转顺序。\n上面已经说了，第一块砖只能是$p_i=1$，所以我们可以从第一块砖出发。\n假如砖的颜色和目标颜色不一致，那就翻转，翻转完第一块砖的颜色就是目标颜色了（已经调整完毕确定了）。\n但刚才在调整上面第一块时，同时也调整了后一块砖，那么我们就要去检查后一块砖的颜色状态了，此时这一块砖也变成了未检查序列的第一块砖，后面同理，最后如果当第$n-1$块砖也调整完毕为目标颜色后，第$n$块砖还不是目标颜色，那就说明调整为该目标颜色不可行。\n那我们就换一个目标颜色。调整检查过程如上，如果还是不可行，就说明这列砖没办法调整为颜色相同。\n从上述分析也可以发现调整次数最多$n-1$次操作，一定不会超过$3n$次。\n代码 import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Main { static int n; //翻转颜色 static void reverse(char[] s, int i) { if (s[i] == \u0026#39;W\u0026#39;) { s[i] = \u0026#39;B\u0026#39;; } else { s[i] = \u0026#39;W\u0026#39;; } } static boolean check(char[] s, char colour) { ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n - 1; ++i) { if (s[i] != colour) { reverse(s, i); reverse(s, i + 1); list.add(i);//将调整操作存起来 } } //最后一个字符元素只可能被前面的元素一起翻转，所以最后只要检查他和目标颜色是否一致，不一致就说明该数组没办法颜色一致 if (s[n - 1] != colour) { return false; } System.out.println(list.size()); if (list.size() != 0) { for (Integer i : list) { System.out.print(i + 1 + \u0026#34; \u0026#34;); } System.out.println(); } return true; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for (int i = 1; i \u0026lt;= t; ++i) { n = scanner.nextInt(); char[] s = scanner.next().toCharArray(); char[] chars = Arrays.copyOf(s, n);//记得复制一次，原来的数组已经被第一次检查修改过啦 //检查要么全黑，要么全白 if (!check(s, \u0026#39;W\u0026#39;) \u0026amp;\u0026amp; !check(chars, \u0026#39;B\u0026#39;)) { System.out.println(-1); } } } } ","permalink":"https://iriseve.github.io/posts/algorithm/acwing3777.%E7%A0%96%E5%9D%97/","summary":"好久没水题解了，水一水","title":"Acwing 3777.砖块"},{"content":"nextLine和next都是读取输入台输入的字符。\nnextLine() 会读取字符前后的空格和tab 只要遇到回车，就停止读取 读取的是回车前的所有字符 会读取换行符，但不会显示 next() 不会读取有效字符前的空格、tab、回车\n读取到有效字符后，遇到空格、tab、回车才会停止读取\n不会读取分隔符\n源码分析 简单看看，写写自己的理解\nScanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的\n而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。\n这个扫描器在扫描过程中判断停止的依据就是“空白符”，比如空格，回车，tab 等等\nnext()方法的分隔匹配模式是空白符\n而nextLine()的分隔符只有\u0026quot;\\r\\n\u0026quot;\n同时，有一点要注意，next()方法只会读取有效字符串，意思就是在缓冲区内如果有效字符串前有空白符，直接过滤，而在有效字符串后有空白符，那就结束了。\n所以next()、next()出现，一般不会出现什么奇怪的问题，因为它只会读字符串\n同理，nextLine、next顺序出现，也不会有什么问题\n但nextLine()不一样，在缓冲区内遇到换行符前它都会读取，也就是它是会读取空白符的。\n至此，我们就可以发现如果同时出现next()和nextLine()，且按照next在前nextLine在后，那么next读取完有效字符后，它还会在缓冲区留下空白符，如果只是空格+字符，那nextLine就会读取空格+字符，但如果还留下了换行符呢？那就危险了，nextLine会把换行符给读了，而换行符又是它的分隔符，那么这个nextLine就读不到有效字符了。\n那么就还有最后一个问题，nextLine()、nextLine()这样出现，会不会出现什么问题呢？\n以前一直这么用，没出国什么问题，但没深究它对分隔符的处理。\n网上查了下，说它读取和不读取换行符的都有。个人更偏向会读取，否则就和上面next、nextLine就矛盾了，当然可以说nextLine读取的是缓冲区内换行符之前的有效字符，因为为空，所以它的输出也是空字符串。\n那么nextLine、nextLine出现，后一个nextLine应该也只会读到空字符串啊，但实际却不是如此。\n这里最根本的分歧就是，如果nextLine读换行符，那为什么不输出呢？\n我们来看看源码。\npublic String nextLine() { if (hasNextPattern == linePattern()) return getCachedResult(); clearCaches(); String result = findWithinHorizon(linePattern, 0); if (result == null) throw new NoSuchElementException(\u0026#34;No line found\u0026#34;); MatchResult mr = this.match(); String lineSep = mr.group(1); if (lineSep != null) result = result.substring(0, result.length() - lineSep.length()); if (result == null) throw new NoSuchElementException(); else return result; } 真相大白，nextline会读分隔符，但输出的时候过滤掉了，因为它是空白符（或许可以这里理解..\n总结下没用的知识 next()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中 nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉 如果要用next+nextLine,最好在next后面再加个nextLine，清理下缓冲区。 一段字符串内不会有空格，即连续的字符串，用next就完事，不用管是空格断句、还是换行断句。 如果有空格的字符串，用nextLine吧 ","permalink":"https://iriseve.github.io/posts/tech/scanner%E5%8C%85%E4%B8%8B%E7%9A%84nextline%E5%92%8Cnext/","summary":"用Scanner时输入方法中的一些坑","title":"Scanner包下的nextLine()和next()"},{"content":"当远程仓库和本地仓库有相同文件而内容不同时会出现该情况，导致无法推送更新。\n思考1 如果我远程先更新完，在本地工作区还没提交到本地仓库时，先把远程pull下来呢，这样可以让我的本地工作区先合并一下吗？\n答案是：不会的，本地工作区有修改还没add commit到本地仓库时的时候使用pull命令会报错\n思考2 如果我本地仓库提交的是空文件，远程仓库有该文件，但文件有内容，这样的情况能直接pull下来吗？\n答：可以的，使用pull命令后检查本地工作区，本地能将远程的拷贝下来。\n这种方式一般用于初始化的时候。在开发过程中感觉不太可能，总不能你想修改个同文件还和对方商量好时间顺序把hhhhh,太麻烦啦~\n比较容易发生的 多人本地有同一份文件，同时对这份文件做不同处理，导致本地文件不同，其中一人先提交了代码，导致远程和其他人本地文件不同出现冲突。\n$ git add . $ git commit -m\u0026#34;xxx\u0026#34; $ git pull --rebase origin master remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 938 bytes | 52.00 KiB/s, done. From gitee.com:yillling/test * branch master -\u0026gt; FETCH_HEAD 8b7e6d5..04a715e master -\u0026gt; origin/master Auto-merging final CONFLICT (add/add): Merge conflict in final error: could not apply 9e3a455... final hint: Resolve all conflicts manually, mark them as resolved with hint: \u0026#34;git add/rm \u0026lt;conflicted_files\u0026gt;\u0026#34;, then run \u0026#34;git rebase --continue\u0026#34;. hint: You can instead skip this commit: run \u0026#34;git rebase --skip\u0026#34;. hint: To abort and get back to the state before \u0026#34;git rebase\u0026#34;, run \u0026#34;git rebase --abort\u0026#34;. Could not apply 9e3a455... final 在这之后命令行后面从master变成master|REBASE 冲突个数/冲突个数\n使用 git rebase --continue命令来帮助手动处理冲突\nueser MINGW64 /e/Projects/test (master|REBASE 1/1) $ git rebase --continue 冲突文件: needs merge You must edit all merge conflicts and then mark them as resolved using git add 手动处理冲突 只要在冲突文件中加入远程仓库中的内容即可，位置没有要求，只要有远程的内容就ok\n然后再执行add和commit操作，再用 git rebase --continue命令检查\n$ git rebase --continue Successfully rebased and updated refs/heads/master. 之后就又回到master了。\n接下来正常push就好了。\n以上主要使用命令行操作的。用idea的话应该有可视化更简单。\n","permalink":"https://iriseve.github.io/posts/tech/git%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","summary":"遇到冲突的一些思考","title":"Git遇到冲突的一些思考"},{"content":"定义方法 Java 5提供了变长参数，允许 在调用方法时传入不定长度的参数 。\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n本质上还是基于数组的实现 。方法签名是一致的。 可变参数可以兼容数组，反之则不成立 。\n//两者等价，所以无法构成方法重载。 //如果同时出现，无法编译通过。 void func(typeName... args); //参数为可变参数 void func(typeName[] args); //参数为typeName数组 泛型机制不能和个数可变的形参配合使用。 调用 把可变参数当作数组来看待使用，其他都一样。\n重载 优先匹配固定参数 public class Varargs { public static void test(String... args) { System.out.println(\u0026#34;version 1\u0026#34;); } public static void test(String arg1, String arg2) { System.out.println(\u0026#34;version 2\u0026#34;); } public static void main(String[] args) { test(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;);//version 2 优先匹配固定参数的重载方法 test();//version 1 } } 不能匹配多个可变参数 调用一个被重载的方法时，如果此调用既能够和两个可变长参数的重载方法匹配，则编译出错:\npublic class Varargs { public static void test(String... args) { System.out.println(\u0026#34;version 1\u0026#34;); } public static void test(String arg1, String... arg2) { System.out.println(\u0026#34;version 3\u0026#34;); } public static void main(String[] args) { test(\u0026#34;a\u0026#34;); } } 注意null值和空值对不同类型的可变参数的影响! Object\u0026hellip; public class VarArgsTest3 { public static void foo(Object... args) { System.out.println(args.length); } public static void main(String[] args) { foo(new String[]{\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;arg3\u0026#34;}); //3 foo(100, new String[]{\u0026#34;arg1\u0026#34;, \u0026#34;arg1\u0026#34;}); //2 foo(new Integer[]{1, 2, 3}); //3 Integer[]可以转型为Object[],作为一个对象数组 foo(100, new Integer[]{1, 2, 3}); //2 foo(1, 2, 3); //3 foo(new int[]{1, 2, 3}); //1 int[]无法转型为Object[] } } 同理，在反射方法调用时也需要注意。\n反射是运行时获取的，在运行时看来，可变长参数和数组是一致的。\nObject invoke(Object obj, Object... args) args虽然是一个可变长度的参数，但是 args 的长度是受限于该方法对象代表的真实方法的参数列表长度的，而从运行时签名来看，可变参数 实际上只有一个形参，即 String[] varargs，因而 invoke(Object obj, Object… args) 中可变参数 args 的实参长度只能为1 。\n总结 在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…} 。\n但在方法可能发生重载时，最好不要用！避免发生一些没必要的问题hhha\n参考 Java 可变参数\n","permalink":"https://iriseve.github.io/posts/tech/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","summary":"可变参数的简单使用","title":"可变参数"},{"content":"问题描述 在idea中创建类，在运行成功同时javac命令生成class文件成功的前提下，java命令报错找不到或无法加载主类\n问题解决 使用javac命令生成的class文件应该和java类文件在同一目录下。 使用java命令-cp参数 java -cp \u0026lt;目录1;目录2;...\u0026gt; 全限定类名 这种方式是JDK1.5后官方建议的方式。\n当你在命令行下运行java命令时，如果没有指定-classpath参数，那么默认使用环境变量中设置的ClASSPATH。\n官方建议，你在运行每个程序时，为其显示设置所依赖的类文件所在的位置，而不是使用“全局”性质的环境变量中CLASSPATH。一旦你运行程序时指定了-classpath参数，环境变量中的CLASSPATH就不会在使用，而是使用你参数的classpath。\n这里注意全限定类名：包名+类名。\n如果是多个module，cd到该模块下执行对应操作即可。\n包是否为空，只要检查代码上是否含有package语句。\n参考 Java命令行运行错误: 找不到或无法加载主类\n","permalink":"https://iriseve.github.io/posts/tech/javacjava/","summary":"java命令报错：找不到或无法加载主类","title":"javac\u0026java"},{"content":" 进行仓库push的时候，出现报错：Failed to connect to github.com port 443 after 2375 ms: Connection refused\n一开始以为是最近github又不太稳定需要挂梯子，所以直接推连接不上\u0026hellip;\n解决方法 重启Pycharm 关闭代理 git config --global --unset http.proxy git config --global --unset https.proxy 添加全局代理： git config --global http.proxy git config --global https.proxy 还是报错~呜呜\n修改IP地址和域名间映射 通过GitHub: Where the world builds software · GitHub (ipaddress.com) 查询github.com的ip地址\n在C:\\Windows\\System32\\drivers\\etc路径下找到hosts文件\n添加\n140.82.112.3 github.com 参考 Failed to connect to github.com port 443: Connection refused问题解决\nhosts文件修改,文件类型修改\n","permalink":"https://iriseve.github.io/posts/tech/github%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF/","summary":"git推送奇奇怪怪的小错误","title":"Github仓库推送连接错误"},{"content":" 写登录认证拦截器的时候碰到一个小问题：在拦截器中如果没有用到mapper、service时，一切正常;\n但是一旦用到mapper、service，就报空指针异常\n一开始以为是没有查到数据（事实上没查到和查不了是两回事~~只是简单没查到的话也应该返回一个空对象）\n不过通过debug，发现是mapper为空，也就是根本没有注入！！先后检查了mapper、interceptor有没有分别加上@Mapper、@Component，发现都解决不了。\n猜测 是不是拦截器创建的时候，mapper还没来得及注入?\n结果 还真是这样\u0026hellip;.\n拦截器原来的配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new JWTInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;);//其他接口验证token直接拦截器拦截 } } 注意看！这里是在添加拦截器的时候new了一个拦截器，并没有将拦截器托管给IOC容器，所以就有了一个先后（我猜的）\n修改后的配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Bean public JWTInterceptor jwtInterceptor(){ return new JWTInterceptor(); } @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(jwtInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .addPathPatterns(\u0026#34;/logout\u0026#34;); } } 将拦截器注成bean交给Spring托管\n参考 拦截器中不能注入Java bean?\nSpringBoot自定义拦截器注入Service_\n","permalink":"https://iriseve.github.io/posts/tech/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%AD%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5mapperservice/","summary":"第一次用springboot遇到的小问题","title":"拦截器中无法注入Mapper,Service"}]