[{"content":"nextLine和next都是读取输入台输入的字符。\nnextLine() 会读取字符前后的空格和tab 只要遇到回车，就停止读取 读取的是回车前的所有字符 会读取换行符，但不会显示 next() 不会读取有效字符前的空格、tab、回车\n读取到有效字符后，遇到空格、tab、回车才会停止读取\n不会读取分隔符\n源码分析 简单看看，写写自己的理解\nScanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的\n而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。\n这个扫描器在扫描过程中判断停止的依据就是“空白符”，比如空格，回车，tab 等等\nnext()方法的分隔匹配模式是空白符\n而nextLine()的分隔符只有\u0026quot;\\r\\n\u0026quot;\n同时，有一点要注意，next()方法只会读取有效字符串，意思就是在缓冲区内如果有效字符串前有空白符，直接过滤，而在有效字符串后有空白符，那就结束了。\n所以next()、next()出现，一般不会出现什么奇怪的问题，因为它只会读字符串\n同理，nextLine、next顺序出现，也不会有什么问题\n但nextLine()不一样，在缓冲区内遇到换行符前它都会读取，也就是它是会读取空白符的。\n至此，我们就可以发现如果同时出现next()和nextLine()，且按照next在前nextLine在后，那么next读取完有效字符后，它还会在缓冲区留下空白符，如果只是空格+字符，那nextLine就会读取空格+字符，但如果还留下了换行符呢？那就危险了，nextLine会把换行符给读了，而换行符又是它的分隔符，那么这个nextLine就读不到有效字符了。\n那么就还有最后一个问题，nextLine()、nextLine()这样出现，会不会出现什么问题呢？\n以前一直这么用，没出国什么问题，但没深究它对分隔符的处理。\n网上查了下，说它读取和不读取换行符的都有。个人更偏向会读取，否则就和上面next、nextLine就矛盾了，当然可以说nextLine读取的是缓冲区内换行符之前的有效字符，因为为空，所以它的输出也是空字符串。\n那么nextLine、nextLine出现，后一个nextLine应该也只会读到空字符串啊，但实际却不是如此。\n这里最根本的分歧就是，如果nextLine读换行符，那为什么不输出呢？\n我们来看看源码。\npublic String nextLine() { if (hasNextPattern == linePattern()) return getCachedResult(); clearCaches(); String result = findWithinHorizon(linePattern, 0); if (result == null) throw new NoSuchElementException(\u0026#34;No line found\u0026#34;); MatchResult mr = this.match(); String lineSep = mr.group(1); if (lineSep != null) result = result.substring(0, result.length() - lineSep.length()); if (result == null) throw new NoSuchElementException(); else return result; } 真相大白，nextline会读分隔符，但输出的时候过滤掉了，因为它是空白符（或许可以这里理解..\n总结下没用的知识 next()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\\r”在缓冲区中 nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉 如果要用next+nextLine,最好在next后面再加个nextLine，清理下缓冲区。 一段字符串内不会有空格，即连续的字符串，用next就完事，不用管是空格断句、还是换行断句。 如果有空格的字符串，用nextLine吧 ","permalink":"https://iriseve.github.io/posts/tech/scanner%E5%8C%85%E4%B8%8B%E7%9A%84nextline%E5%92%8Cnext/","summary":"用Scanner时输入方法中的一些坑","title":"Scanner包下的nextLine()和next()"},{"content":"当远程仓库和本地仓库有相同文件而内容不同时会出现该情况，导致无法推送更新。\n思考1 如果我远程先更新完，在本地工作区还没提交到本地仓库时，先把远程pull下来呢，这样可以让我的本地工作区先合并一下吗？\n答案是：不会的，本地工作区有修改还没add commit到本地仓库时的时候使用pull命令会报错\n思考2 如果我本地仓库提交的是空文件，远程仓库有该文件，但文件有内容，这样的情况能直接pull下来吗？\n答：可以的，使用pull命令后检查本地工作区，本地能将远程的拷贝下来。\n这种方式一般用于初始化的时候。在开发过程中感觉不太可能，总不能你想修改个同文件还和对方商量好时间顺序把hhhhh,太麻烦啦~\n比较容易发生的 多人本地有同一份文件，同时对这份文件做不同处理，导致本地文件不同，其中一人先提交了代码，导致远程和其他人本地文件不同出现冲突。\n$ git add . $ git commit -m\u0026#34;xxx\u0026#34; $ git pull --rebase origin master remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 938 bytes | 52.00 KiB/s, done. From gitee.com:yillling/test * branch master -\u0026gt; FETCH_HEAD 8b7e6d5..04a715e master -\u0026gt; origin/master Auto-merging final CONFLICT (add/add): Merge conflict in final error: could not apply 9e3a455... final hint: Resolve all conflicts manually, mark them as resolved with hint: \u0026#34;git add/rm \u0026lt;conflicted_files\u0026gt;\u0026#34;, then run \u0026#34;git rebase --continue\u0026#34;. hint: You can instead skip this commit: run \u0026#34;git rebase --skip\u0026#34;. hint: To abort and get back to the state before \u0026#34;git rebase\u0026#34;, run \u0026#34;git rebase --abort\u0026#34;. Could not apply 9e3a455... final 在这之后命令行后面从master变成master|REBASE 冲突个数/冲突个数\n使用 git rebase --continue命令来帮助手动处理冲突\nueser MINGW64 /e/Projects/test (master|REBASE 1/1) $ git rebase --continue 冲突文件: needs merge You must edit all merge conflicts and then mark them as resolved using git add 手动处理冲突 只要在冲突文件中加入远程仓库中的内容即可，位置没有要求，只要有远程的内容就ok\n然后再执行add和commit操作，再用 git rebase --continue命令检查\n$ git rebase --continue Successfully rebased and updated refs/heads/master. 之后就又回到master了。\n接下来正常push就好了。\n以上主要使用命令行操作的。用idea的话应该有可视化更简单。\n","permalink":"https://iriseve.github.io/posts/tech/git%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","summary":"遇到冲突的一些思考","title":"Git遇到冲突的一些思考"},{"content":"定义方法 Java 5提供了变长参数，允许 在调用方法时传入不定长度的参数 。\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n本质上还是基于数组的实现 。方法签名是一致的。 可变参数可以兼容数组，反之则不成立 。\n//两者等价，所以无法构成方法重载。 //如果同时出现，无法编译通过。 void func(typeName... args); //参数为可变参数 void func(typeName[] args); //参数为typeName数组 泛型机制不能和个数可变的形参配合使用。 调用 把可变参数当作数组来看待使用，其他都一样。\n重载 优先匹配固定参数 public class Varargs { public static void test(String... args) { System.out.println(\u0026#34;version 1\u0026#34;); } public static void test(String arg1, String arg2) { System.out.println(\u0026#34;version 2\u0026#34;); } public static void main(String[] args) { test(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;);//version 2 优先匹配固定参数的重载方法 test();//version 1 } } 不能匹配多个可变参数 调用一个被重载的方法时，如果此调用既能够和两个可变长参数的重载方法匹配，则编译出错:\npublic class Varargs { public static void test(String... args) { System.out.println(\u0026#34;version 1\u0026#34;); } public static void test(String arg1, String... arg2) { System.out.println(\u0026#34;version 3\u0026#34;); } public static void main(String[] args) { test(\u0026#34;a\u0026#34;); } } 注意null值和空值对不同类型的可变参数的影响! Object\u0026hellip; public class VarArgsTest3 { public static void foo(Object... args) { System.out.println(args.length); } public static void main(String[] args) { foo(new String[]{\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;arg3\u0026#34;}); //3 foo(100, new String[]{\u0026#34;arg1\u0026#34;, \u0026#34;arg1\u0026#34;}); //2 foo(new Integer[]{1, 2, 3}); //3 Integer[]可以转型为Object[],作为一个对象数组 foo(100, new Integer[]{1, 2, 3}); //2 foo(1, 2, 3); //3 foo(new int[]{1, 2, 3}); //1 int[]无法转型为Object[] } } 同理，在反射方法调用时也需要注意。\n反射是运行时获取的，在运行时看来，可变长参数和数组是一致的。\nObject invoke(Object obj, Object... args) args虽然是一个可变长度的参数，但是 args 的长度是受限于该方法对象代表的真实方法的参数列表长度的，而从运行时签名来看，可变参数 实际上只有一个形参，即 String[] varargs，因而 invoke(Object obj, Object… args) 中可变参数 args 的实参长度只能为1 。\n总结 在不确定方法需要处理的对象的数量时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 new T[]{…} 。\n但在方法可能发生重载时，最好不要用！避免发生一些没必要的问题hhha\n参考 Java 可变参数\n","permalink":"https://iriseve.github.io/posts/tech/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","summary":"可变参数的简单使用","title":"可变参数"},{"content":"问题描述 在idea中创建类，在运行成功同时javac命令生成class文件成功的前提下，java命令报错找不到或无法加载主类\n问题解决 使用javac命令生成的class文件应该和java类文件在同一目录下。 使用java命令-cp参数 java -cp \u0026lt;目录1;目录2;...\u0026gt; 全限定类名 这种方式是JDK1.5后官方建议的方式。\n当你在命令行下运行java命令时，如果没有指定-classpath参数，那么默认使用环境变量中设置的ClASSPATH。\n官方建议，你在运行每个程序时，为其显示设置所依赖的类文件所在的位置，而不是使用“全局”性质的环境变量中CLASSPATH。一旦你运行程序时指定了-classpath参数，环境变量中的CLASSPATH就不会在使用，而是使用你参数的classpath。\n这里注意全限定类名：包名+类名。\n如果是多个module，cd到该模块下执行对应操作即可。\n包是否为空，只要检查代码上是否含有package语句。\n参考 Java命令行运行错误: 找不到或无法加载主类\n","permalink":"https://iriseve.github.io/posts/tech/javacjava/","summary":"java命令报错：找不到或无法加载主类","title":"javac\u0026java"},{"content":" 进行仓库push的时候，出现报错：Failed to connect to github.com port 443 after 2375 ms: Connection refused\n一开始以为是最近github又不太稳定需要挂梯子，所以直接推连接不上\u0026hellip;\n解决方法 重启Pycharm 关闭代理 git config --global --unset http.proxy git config --global --unset https.proxy 添加全局代理： git config --global http.proxy git config --global https.proxy 还是报错~呜呜\n修改IP地址和域名间映射 通过GitHub: Where the world builds software · GitHub (ipaddress.com) 查询github.com的ip地址\n在C:\\Windows\\System32\\drivers\\etc路径下找到hosts文件\n添加\n140.82.112.3 github.com 参考 Failed to connect to github.com port 443: Connection refused问题解决\nhosts文件修改,文件类型修改\n","permalink":"https://iriseve.github.io/posts/tech/github%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF/","summary":"git推送奇奇怪怪的小错误","title":"Github仓库推送连接错误"},{"content":" 写登录认证拦截器的时候碰到一个小问题：在拦截器中如果没有用到mapper、service时，一切正常;\n但是一旦用到mapper、service，就报空指针异常\n一开始以为是没有查到数据（事实上没查到和查不了是两回事~~只是简单没查到的话也应该返回一个空对象）\n不过通过debug，发现是mapper为空，也就是根本没有注入！！先后检查了mapper、interceptor有没有分别加上@Mapper、@Component，发现都解决不了。\n猜测 是不是拦截器创建的时候，mapper还没来得及注入?\n结果 还真是这样\u0026hellip;.\n拦截器原来的配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new JWTInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;);//其他接口验证token直接拦截器拦截 } } 注意看！这里是在添加拦截器的时候new了一个拦截器，并没有将拦截器托管给IOC容器，所以就有了一个先后（我猜的）\n修改后的配置 @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Bean public JWTInterceptor jwtInterceptor(){ return new JWTInterceptor(); } @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(jwtInterceptor()) .addPathPatterns(\u0026#34;/user/**\u0026#34;) .addPathPatterns(\u0026#34;/logout\u0026#34;); } } 将拦截器注成bean交给Spring托管\n参考 拦截器中不能注入Java bean?\nSpringBoot自定义拦截器注入Service_\n","permalink":"https://iriseve.github.io/posts/tech/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%AD%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5mapperservice/","summary":"第一次用springboot遇到的小问题","title":"拦截器中无法注入Mapper,Service"}]